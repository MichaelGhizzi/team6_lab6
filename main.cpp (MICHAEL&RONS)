//GROUP_6
//Alec Nghiem - kou.alec@csu.fullerton.edu
//Deshawn Dana - dashwen@csu.fullerton.edu
//Michael Ghizzi - michaelghizzi@csu.fullerton.edu
//Ronald Dubarry - r_dubarry@csu.fullerton.edu
//Tony Dao - sangdao2014@csu.fullerton.edu

#include <iostream>
#include <fstream>
#include <string>
#include "ROWS.h"
#include "Parse.h"
#include "Parse.cpp"
using namespace std;

void fileread(string);

//Conversion Table
string convertTable(char hexNumber)
{
	if (hexNumber == '0')
	{ 
		return "0000";
	}
	if (hexNumber == '1')
	{ 
		return "0001"; 
	}
	if (hexNumber == '2')
	{ 
		return "0010"; 
	}
	if (hexNumber == '3')
	{ 
		return "0011";
	}
	if (hexNumber == '4')
	{ 
		return "0100";
	}
	if (hexNumber == '5')
	{ 
		return "0101"; 
	}
	if (hexNumber == '6')
	{ 
		return "0110"; 
	}
	if (hexNumber == '7')
	{ 
		return "0111"; 
	}
	if (hexNumber == '8')
	{ 
		return "1000";
	}
	if (hexNumber == '9')
	{ 
		return "1001"; 
	}
	if (hexNumber == 'A')
	{
		return "1010";
	}
	if (hexNumber == 'B')
	{ 
		return "1011"; 
	}
	if (hexNumber == 'C')
	{ 
		return "1100";
	}
	if (hexNumber == 'D')
	{ 
		return "1101"; 
	}
	if (hexNumber == 'E')
	{ 
		return "1110"; 
	}
	if (hexNumber == 'F')
	{ 
		return "1111"; 
	}
	if (hexNumber == 'a')
	{ 
		return "1010";
	}
	if (hexNumber == 'b')
	{
		return "1011"; 
	}
	if (hexNumber == 'c')
	{ 
		return "1100"; 
	}
	if (hexNumber == 'd')
	{ 
		return "1101";
	}
	if (hexNumber == 'e')
	{ 
		return "1110"; 
	}
	if (hexNumber == 'f')
	{ 
		return "1111"; 
	}
	return "";
}

//Converts hex numbers to binary
string hexToBinary(string hex)  //converts based on table above
{
	string finalBinary = "";
	for (std::string::size_type i = 0; i < hex.size(); ++i) 
	{
		finalBinary += convertTable(hex[i]);
	}
	return finalBinary;
}

// Converts a binary number to decimal
unsigned long binaryToDecimal(string BinaryInput)
{
	unsigned long currentBinaryValue = 1;
	unsigned long totalValue = 0;
	for (int i = (BinaryInput.size() - 1); i >= 0; --i) 
	{
		if (BinaryInput[i] == '1')
		{ 
			totalValue += currentBinaryValue; 
		}
		currentBinaryValue *= 2;
	}

	return totalValue;
}

string flipBinary(string binaryString)  //beg and ending of string (size)
{
	return string(binaryString.rbegin(), binaryString.rend());
} // its called flip binary since that is what it is used for but it can flip anystring 

string splitString(string bits, int start, int end) //amount of bits, start and end. splits it up, combined with flip bits
{
	string finalbits = "";
	for (int i = start; i <= end; i++)
	{
		finalbits += bits[i];
	}
	return finalbits;
} // alternative to bitmasking

string reverseWords(string hex)
{
	return flipBinary(hexToBinary(splitString(hex, 0, 3))) + flipBinary(hexToBinary(splitString(hex, 4, 7)));
} // this takes the hex and splits it into its two words, then it turns it into binary and then flips the binary. 

// Converts a hex number to decimal
unsigned long hexToDecimal(string hex)
{
	string finalBinary = "";

	for (std::string::size_type i = 0; i < hex.size(); ++i) 
	{
		finalBinary += convertTable(hex[i]);
	}
	string BinaryInput = finalBinary;

	unsigned long currentBinaryValue = 1;
	unsigned long totalValue = 0;

	for (int i = (BinaryInput.size() - 1); i >= 0; --i) 
	{
		if (BinaryInput[i] == '1')
		{ 
			totalValue += currentBinaryValue; 
		}
		currentBinaryValue *= 2;
	}
	return totalValue;
}

// Main function
int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		cout << "Must provide a file ex: ./<program> <file>" << endl;
	}
	else 
	{
		fileread(argv[1]);
	}
	return 0;
}

//Declare pointer to type of array
//pointer to an array, which traverses line through line in the file.
ROW *row;

//makes program run very fast.
//finds size of file and assumes the size and divide by 75, and gives us the estimated amount of lines.
//safe function
//ensures that we know how many lines that program has to traverse through
//assumes that 1-75 that will be valid, so we need to store them in an array element.
long fastcountlines(string filename)
{
	FILE * pFile;
	long size;

	pFile = fopen(filename.c_str(), "rb");

	if (pFile == NULL) perror("Error opening file");
	else
	{
		fseek(pFile, 0, SEEK_END);   // non-portable
		size = ftell(pFile);
		fclose(pFile);
		return (size / 75); //Divide by 75 to avoid junk values
	}
	return 0;
}

//Counts the number of lines in file
//can delete, doesnt do anything
long slowcountlines(string filename)
{	
	ifstream readfile;
	readfile.open(filename.c_str());

	char c;
	long h = 0;
	while (readfile.get(c))
	if (c == '\n')
		++h;

	readfile.close();
	return h;
}

// Reads from the file
void fileread(string filename)
{
	long h = fastcountlines(filename);  //fast count
	ifstream readfile;

	readfile.open(filename.c_str());

	row = new ROW[h];                   //make row size of h

	// Reads in column information from file 
	int i = 0;

	while (!readfile.eof())  //Need to skip the first line (title)  //ws = white space
	{
		readfile >> row[i].Col_Sample >> ws >> row[i].Col_BgL >> ws >> row[i].Col_RelTime >> ws >>
			row[i].Col_AbsTime >> ws >> row[i].Col_Transfer >> ws >> row[i].Col_AM_XAM >> ws >>
			row[i].Col_Address >> ws >> row[i].Col_Data >> ws >> row[i].Col_Size >> ws >>
			row[i].Col_Cycle >> ws >> row[i].Col_Status >> ws >> row[i].Col_Iack >> ws >>
			row[i].Col_Fail >> ws >> row[i].Col_IRQ;
		i++;    //current line number, need to pass through for lines
	}

	readfile.close();

	string DataBuffer;
	bool active = false;    //have active because needs to know when the convert the data, and write it. Used as an on / off mechanism.
	int wordcount = 0;
	string sdds = "Wr D-to-S";
	for (int j = 0; j < i; j++)
    {
        // Address 0x40000810 contains the length of the S-to-D command in number of bytes
		if (hexToDecimal(row[j].Col_Address) == 1073743888) //can typecast to decimal to from the current hex string to make faster
		{                                       //when we hit this block that when it has the equivalent value to this, it sets the active = true, when it hits it the second time
                                                //it takes all the information in the datablock and parses.
                                                //then it gets emptied, and it starts all over again.
			if (!DataBuffer.empty() && active)
            {
				DataBuffer = sdds + "|" + to_string((wordcount / 2)) + "|" + DataBuffer;
				Parse parser(DataBuffer);
				DataBuffer.clear();
				wordcount = hexToDecimal(row[j].Col_Data);
				sdds = row[j].Col_Cycle + " S-to-D";
			}
			else if (active)
            {
				DataBuffer = sdds + "|" + to_string((wordcount / 2)) + "|" + DataBuffer;
				Parse parser(DataBuffer);
				DataBuffer.clear();
				wordcount = hexToDecimal(row[j].Col_Data); //this needs to be fixed and determined by parse perhaps the first thing in the parse should be the function callers data
				sdds = row[j].Col_Cycle + " S-to-D";
			}
			active = true;  //determines whether youre currently getting information that youre having to parse, so it sets it to false when youre done parsing that individual data block
		}

		// Address 0x40000818 to 0x40000C14 contains the data of the S-to-D command
		else if (hexToDecimal(row[j].Col_Address) >= 1073743896 && hexToDecimal(row[j].Col_Address) <= 1073744916)
		{
			// check if the data is coming in in low to high or high to low format and based on this append to buffer whichever way fits
			if (hexToDecimal(row[j].Col_Address) > hexToDecimal(row[j - 1].Col_Address) && hexToDecimal(row[j].Col_Address) != 1073743888)
            {
				DataBuffer += reverseWords(row[j].Col_Data) + "|";      //databuffer = where the data is the data is being appended too for the block
			}
			else
            {
				DataBuffer = reverseWords(row[j].Col_Data) + "|" + DataBuffer;
			}

		}

		// Address 0x40000C18 contains the length of the D-to-S command in number of bytes
		else if (hexToDecimal(row[j].Col_Address) == 1073744920)    //
		{
			if (!DataBuffer.empty() && active)
            {
				DataBuffer = sdds + "|" + to_string((wordcount / 2)) + "|" + DataBuffer;
				Parse parser(DataBuffer);
				DataBuffer.clear();
				wordcount = hexToDecimal(row[j].Col_Data);
				sdds = row[j].Col_Cycle + " D-to-S";
			}
			else if (active)
            {
				DataBuffer = sdds + "|" + to_string((wordcount / 2)) + "|" + DataBuffer;
				Parse parser(DataBuffer);
				DataBuffer.clear();
				wordcount = hexToDecimal(row[j].Col_Data);
				sdds = row[j].Col_Cycle + " D-to-S";
			}
			active = true;
		}

		// Address 0x40000C20 to 0x4000101C contains the data of the D-to-S command
		else if (hexToDecimal(row[j].Col_Address) >= 1073744928 && hexToDecimal(row[j].Col_Address) <= 1073745948)
		{
			// check if the data is coming in in low to high or high to low format and based on this append to buffer whichever way fits
			if (hexToDecimal(row[j].Col_Address) > hexToDecimal(row[j - 1].Col_Address) && hexToDecimal(row[j].Col_Address) != 1073744920)
            {
				DataBuffer += reverseWords(row[j].Col_Data) + "|";
			}
			else
            {
				DataBuffer = reverseWords(row[j].Col_Data) + "|" + DataBuffer;
			}
		}

		else
		{

		}
	}

	Parse parser(DataBuffer);
}
